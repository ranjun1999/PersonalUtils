package com.ranjun1999.personalutils.算法.nowcoder.sort;

/**
 * @Author: ranjun
 * @Date: 2020/3/25 10:57
 *
 * 希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更短的列（步长更短了，列数更少了）来进行。
 * 最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。
 *
 * 例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样(竖着的元素是步长组成)：
 *
 * 13 14 94 33 82
 * 25 59 94 65 23
 * 45 27 73 25 39
 * 10
 * 然后我们对每列进行排序：
 *
 * 10 14 73 25 23
 * 13 27 94 33 39
 * 25 59 94 65 82
 * 45
 * 将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]。这时10已经移至正确位置了，然后再以3为步长进行排序：
 *
 * 10 14 73
 * 25 23 13
 * 27 94 33
 * 39 25 59
 * 94 65 82
 * 45
 * 排序之后变为：
 *
 * 10 14 13
 * 25 23 33
 * 27 25 59
 * 39 65 73
 * 45 94 82
 * 94
 * 最后以1步长进行排序（此时就是简单的插入排序了）
 */
public class 希尔排序 {

    public static void shellSort(int[] arr) {
        if(arr == null || arr.length <= 1)
            return;
        int n = arr.length;
        //步长每次缩小两倍
        int grep = n/2;

        while (grep > 0) {
            //将每一列进行插入排序
            for (int i = grep;i < n;i++)
            {
                int j = i;
                //从下至上进行比较并将较小值交换至上一列
                while (j >= grep && arr[j - grep] > arr[j]) {
                    int temp = arr[j - grep];
                    arr[j - grep] = arr[j];
                    arr[j] = temp;
                    j -= grep;
                }
            }

            grep = grep/2;
        }

    }

    public static void main(String[] args) {
        int[] ins = {2,3,5,1,23,6,78,34,23,4,5,78,34,65,32,65,76,32,76,1,9};
        shellSort(ins);
        for (int i = 0; i < ins.length; i++) {
            System.out.print(i + ", ");
        }
    }

}
